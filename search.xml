<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Insertion Sort]]></title>
    <url>%2F2019%2F07%2F04%2FInsertion-Sort%2F</url>
    <content type="text"><![CDATA[ProblemInput:A sequence of n numbers ​ Output:A permutation(reordering) of the input sequence ​ $&lt;a_1^{‘},a_2^{‘},…,a_n^{‘}&gt;$ such that ​ $a_1^{‘}\leq a_2^{‘}\leq …\leq a_n^{‘}$ Algorithm Treat the sequence as a hand of poker cards.Use the order of index(natrual numbers) the iterate the list. Construct a list with an array to realize insertion sort. The list elements are sorted and we can traverse on it or add new elements to it. Pay attention to the trick applied on the code. 1234567for j=2 to A.length key=A[j] i=j-1 while i&gt;0 and A[i]&gt;key A[i+1]=A[i] i=i-1 A[i+1]=key Loop InvariantYou can regard loop invariant as an application of mathematical induction in computer science. Since algorithms use iterative approach,it’s vital for us to use induction to prove that this algorithm is right. Three things about a loop invariant: Initialization:The first iteration of the loop is correct Maintenance:If it is true before an iteration of the loop and it remains true before the next iteration,then the proverties maintain in the loop process. Termination:When the loop terminates,the invariant gives us a useful property that helps show that the algorithm is correct. eg.Take insertion sort as an example: Initialization:when j=2,the array only consists of A[1].This subarray is sorted. Maintenance:The loop works by moving A[j-1],A[j-2],A[j-3]… by one position right until it finds the proper position for A[j],at which point it inserts the value of A[j].The subarray A[1..j] then consists of the elements originally in A[1..j],but in sorted order.Increasing j for the next iteration preserves the loop invariant. Termination:The condition causing for loop to terminate is that j&gt;A.length=n.Then we have the subarray A[1..n] consists of the elements originally in A[1..n],but in sorted order.Observing the A[1..n] is the entire array,we conclude that the entire array is sorted!Hence the algorithm is correct. Analysis12345678 cost timesfor j=2 to A.length c1 n key=A[j] c2 n-1 i=j-1 c4 n-1 while i&gt;0 and A[i]&gt;key c5 $$\sum_&#123;j=2&#125;^&#123;n&#125;t_j$$ A[i+1]=A[i] c6 $$\sum_&#123;j=2&#125;^&#123;n&#125;(t_j-1)$$ i=i-1 c7 $$\sum_&#123;j=2&#125;^&#123;n&#125;(t_j-1)$$ A[i+1]=key c8 n-1 running timeT(n),the running time of INSERTION-SORT on an input of n values. ​ $T(n)=c_1n+c_2(n-1)+c_4(n-1)+c_5\sum\limits_{j=2}^{n}t_j+c_6\sum\limits_{j=2}^{n}(t_j-1)+c_7\sum\limits_{j=2}^{n}(t_j-1)+c_8(n-1)$ best caseThe best case occurs if the array is already sorted.For each j=2,3…,n,we then find that A[j]&lt;=key in line 4 when i has its initial value of j-1.Thus tj=1 for j=2,3,…,n and the best-case running time is ​ $T_{best-case}(n)=c_1n+c_2(n-1)+c_4(n-1)+c_5(n-1)+c_8(n-1)\\\quad \quad =(c_1+c_2+c_4+c_5+c_8)n-(c_2+c_4+c_5+c_8)$ We can express this running time as ​ $T_{best-case}(n)=an+b$ for constants a and b that depend on the statement costs cj ;it is thus a linear function of n. worst caseThe worst case occurs if the array is in reverse sorted order. Then we must compare each element A[j] with each element in the entire sorted subarray A[1…j-1],and so tj =j for j=2,3,…,n.Noting that ​ $\sum\limits_{j=2}^{n}j=\frac{n(n+1)}{2}-1\\and\\\sum\limits_{j=2}^{n}(j-1)=\frac{n(n-1)}{2}$ Find that in the worst case,the running time is ​ T_{worst-case}(n)=c_1n+c_2(n-1)+c_4(n-1)+c_5(\frac{n(n+1)}{2}-1)+c_6*\frac{n(n-1)}{2}+c_7*\frac{n(n-1)}{2}+c_8(n-1)\\\quad \quad =\frac{1}{2}(c_5+c_6+c_7)*n^2+(c_1+c_2+c_4+\frac{c_5}{2}-\frac{c_6}{2}-\frac{c_7}{2}+c_8)*n-(c_2+c_4+c_5+c_8) We can express this running time as ​ $T_{worst-case}(n)=an^2+bn+c$ for constants a,b and c that depend on the statement cost cj ;it is thus a quadratic function of n. Order of GrowthIt is the rate of growth,or order of growth of the running time that really interests us. Therefore we consider only the leading term of a formula.And we also ignore the leading term’s constant coefficient. In the case of insertion sort,we write it has a worst-case running time of ​ $\Theta(n^2)$]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Insert Sort List]]></title>
    <url>%2F2019%2F07%2F03%2FInsert-Sort-List%2F</url>
    <content type="text"><![CDATA[ProblemInput:A sequence of n numbers ​ Output:A permutation(reordering) of the input sequence ​ $&lt;a_1^{‘},a_2^{‘},…,a_n^{‘}&gt;$ such that ​ $a_1^{‘}\leq a_2^{‘}\leq …\leq a_n^{‘}$ AlgorithmSimulate the process of insert sort with list. Use 3 arrays to store the list. bb[i] means “bigger brother”,the left node of the current node. lb[i] means “little brother”,the right node of the current node. Everytime we get a new element we insert it into the list by traversing the list to find the first node whose key is bigger than the element and place it on the left. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;int N;struct ChainList &#123; int hd,bb[100100],lb[100100],ke[100100],ind; void ini() &#123; hd = -1; ind = 0; for(int i=0;i&lt;=N+1;++i) &#123; bb[i]=lb[i]= -1; &#125; &#125; void ins(int el) &#123; if(hd==-1) &#123; hd=ind=1; ke[1]=el; return; &#125; ke[++ind]=el; bool sign = false; int iter; for(iter = hd; ; iter = lb[iter]) &#123; if(ke[iter]&gt;=el) &#123; sign = true; lb[bb[iter]]=ind; bb[ind]=bb[iter]; bb[iter]=ind; lb[ind]=iter; if(iter == hd) &#123; hd = ind; &#125; break; &#125; if(lb[iter]==-1) break; &#125; if(!sign) &#123; lb[iter]=ind; bb[ind]=iter; &#125; &#125;&#125;L;int main() &#123; scanf("%d",&amp;N); L.ini(); for(int i = 1; i &lt;= N; ++i) &#123; int el; scanf("%d",&amp;el); L.ins(el); &#125; for(int iter = L.hd; iter != -1; iter = L.lb[iter]) printf("%d ",L.ke[iter]); fclose(stdin); fclose(stdout); return 0;&#125;]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>sort</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wie wird man seinen Schatten los?]]></title>
    <url>%2F2019%2F07%2F03%2FSay-Hi%2F</url>
    <content type="text"><![CDATA[Hello! Listen to this. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Wie wird man seinen Schatten los?你要如何逃离自己的阴影？Wie sagt man seinem Schicksal Nein?你该如何反抗自己的命运？Wie kriecht man aus der eignen Haut?又要如何冲破枷锁？Wie kann man je ein anderer sein?如何得到重生？Wen soll man fragen, wenn man sich selber nicht versteht?如果认不清自己，又能向谁去探寻？Wie kann man frei sein, wenn man seinem eignen Schatten nie entgeht?如果逃离不出自己的阴影，又能如何真正自由？Wenn der Kampf vorüber ist当你停止抗争und dein Weg zu Ende,孤身一人走到最后bist du nur noch, der du bist.你将接近自己的本真Dann zählt nur noch, was unzerstörbar ist.那只有坚不可摧的灵魂才得以永荣Doch solange wir leben,但只要我们还存留于世ist es uns aufgegeben,就算被弃之不顾uns zu fragen, Tag und Nacht:也要日夜追问自己Wie wird man seinen Schatten los?你要如何逃离自己的阴影？Wie sagt man seinem Schicksal Nein?你该如何反抗自己的命运？Wie kriecht man aus der eignen Haut?又要如何冲破枷锁？Wie kann man je ein anderer sein?如何得到重生？Wen soll man fragen, wenn man sich selber nicht versteht?如果认不清自己，又该向谁去探寻？Wie kann man frei sein, wenn man seinem eignen Schatten nie entgeht?如果逃离不出自己的阴影，又能如何真正自由？Wie wird man seinen Schatten los?你要如何逃离自己的阴影？Wie können wir leben,我们该如何生活(Wie lässt man alles hinter sich?)（又如何将一切抛在脑后？）(Wie jagt man sein Gewissen fort?)（该如何背弃自己的良心？）solang wir nur dem Schicksal dienen?假使我们只屈从于命运？(Wie flieht man vor dem eignen ich?)（要如何逃离自己？）(Wie kann man flüchten,)（该如何逃脱？）Wir können nie,我们永远不能(wenn man sich selbst im Wege steht?)(如果你成为了自己的阻碍？）wir können nie我们永远不能nie,永远不能(Vor deinem Schicksal kannst du nicht fliehen!)（你不能在自己的命运面前退缩！）niemals vor unserm eignen Schatten fliehen!永远不要在我们自己的阴影面前退缩！]]></content>
  </entry>
</search>
